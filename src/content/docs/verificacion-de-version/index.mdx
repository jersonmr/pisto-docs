---
title: Verificaci√≥n de versi√≥n
description: Verificaci√≥n de versi√≥n de la aplicaci√≥n.
---

# Flujo de Verificaci√≥n de Versi√≥n

Este documento detalla el proceso de verificaci√≥n de versi√≥n en la aplicaci√≥n, desde el requerimiento inicial hasta la implementaci√≥n t√©cnica final.

## 1. Requerimiento

La aplicaci√≥n implementa un sistema de verificaci√≥n de versi√≥n que se ejecuta en **dos momentos espec√≠ficos**:

1. **Al cargar datos del cliente**: Cuando el usuario hace login o se autentica, la verificaci√≥n se realiza usando la versi√≥n que viene en los datos del usuario (`appVersion` del endpoint `/mobile/client/data`).

2. **Al abrir la aplicaci√≥n**: Para futuras implementaciones, existe un endpoint dedicado `/mobile/check-version` que permite verificar la versi√≥n independientemente.

### Comportamiento del Sistema:

-   Si las versiones son **iguales**, se proceder√° con el flujo normal de la aplicaci√≥n.
-   Si son **diferentes**, la app redirige autom√°ticamente a la pantalla de actualizaci√≥n (`AppVersionScreen`) y **bloquea el acceso** al resto de la aplicaci√≥n.
-   En caso de **error** en la comunicaci√≥n con la API, se mantiene el estado actual y se permite continuar con el flujo normal.

### Variable Global de Versi√≥n

La aplicaci√≥n mantiene una variable global que contiene la versi√≥n instalada, obtenida autom√°ticamente usando `package_info_plus`. Esta versi√≥n se muestra en el panel lateral de la aplicaci√≥n.

## 2. Especificaci√≥n T√©cnica del API

### 2.1. Verificaci√≥n Integrada con Datos del Cliente

La verificaci√≥n principal se realiza a trav√©s del endpoint existente cuando el usuario hace login:

**`GET`** `/mobile/client/data`

-   **Request Headers**:

    -   content-type: application/json
    -   accept: application/json
    -   Authorization: Bearer `{token}`
    -   Language: "es"

-   **Success Response** (incluye `appVersion`):

```json
{
    "data": {
        "appVersion": "1.2.2",
        "id": 14,
        "name": "Pedro",
        "surname": "Mart√≠nez",
        "email": "prueba@prueba.com",
        "profile": { ... },
        "job": { ... }
    }
}
```

### 2.2. Endpoint Dedicado de Verificaci√≥n (Futuro)

Para verificaciones independientes, existe el endpoint:

**`GET`** `/mobile/check-version`

-   **Request Headers**:

    -   content-type: application/json
    -   accept: application/json
    -   Language: "es"

-   **Success Response**:

```json
{
    "data": {
        "version": "1.2.2"
    }
}
```

### 2.3. Nota para Backend

La informaci√≥n de la versi√≥n est√° almacenada en la tabla `app_versions` en la base de datos. Se env√≠a el contenido del campo `version` del √∫ltimo registro de dicha tabla tanto en el endpoint de datos del cliente como en el endpoint dedicado de verificaci√≥n.

## 3. Implementaci√≥n

El flujo de verificaci√≥n de versi√≥n est√° integrado con el sistema de autenticaci√≥n y enrutamiento, ejecut√°ndose autom√°ticamente cuando el usuario se autentica.

### 3.1. Arquitectura de Componentes

**Componentes principales:**

1. **`AppVersionStateNotifier`**: Provider que maneja el estado de verificaci√≥n de versi√≥n
2. **`AppVersionScreen`**: Pantalla que se muestra cuando se necesita actualizar
3. **`RouteMiddleware`**: Middleware que intercepta navegaci√≥n y redirige seg√∫n el estado
4. **`AppState`**: Estado global que incluye `appNeedsUpdate` basado en el provider de versi√≥n

### 3.2. Flujo de Verificaci√≥n Autom√°tica

**Momento de ejecuci√≥n**: La verificaci√≥n se ejecuta autom√°ticamente durante el proceso de autenticaci√≥n:

1. **Login del Usuario**: Cuando el usuario hace login exitoso, `AuthNotifier._setAuthenticatedState()` se ejecuta
2. **Verificaci√≥n Autom√°tica**: Se llama `_appVersionNotifier.checkVersionFromUserData(loginResponse.user.appVersion)`
3. **Comparaci√≥n de Versiones**:
    - Obtiene versi√≥n instalada con `PackageInfo.fromPlatform()`
    - Compara con `serverAppVersion` usando comparaci√≥n sem√°ntica
    - Actualiza `AppVersionState` con resultado (`needsUpdate: true/false`)

### 3.3. L√≥gica del Middleware de Rutas

El `RouteMiddleware.shouldRedirect()` eval√∫a el estado y redirige seg√∫n prioridades:

```dart
// Primera prioridad: Verificaci√≥n de versi√≥n
if (appState.appNeedsUpdate) {
  return currentPath != AppVersionScreen.route
      ? AppVersionScreen.route
      : null;
}

// Contin√∫a con otras verificaciones (onboarding, GPS, auth)...
```

**Comportamiento**:

-   Si `appNeedsUpdate` es `true`, **bloquea toda navegaci√≥n** y fuerza redirecci√≥n a `/app-version`
-   El usuario queda "atrapado" en `AppVersionScreen` hasta actualizar la app
-   No hay forma de continuar sin actualizar (comportamiento intencional)

### 3.4. Pantalla de Actualizaci√≥n (`AppVersionScreen`)

La pantalla muestra una interfaz simple con:

-   **Logo de la aplicaci√≥n**
-   **Mensaje**: "Parece que necesitas actualizar versi√≥n"
-   **Instrucciones**: "Entra a pisto.co para descargar la nueva version"
-   **Bot√≥n "Actualizar Ahora"**: Redirige a `https://pisto.co` usando `url_launcher`

**Caracter√≠sticas**:

-   No tiene opci√≥n "Omitir" o "Cancelar" (bloqueo total)
-   Abre el navegador externo al presionar "Actualizar Ahora"
-   Permanece visible incluso despu√©s de volver del navegador

## 4. Diagrama del Flujo

```mermaid
graph TD
    A[Inicio de la App] --> B[Router Middleware]
    B --> C{Eval√∫a AppState.appNeedsUpdate}

    C -->|false| D[Continuar con flujo normal]
    C -->|true| E[Redirigir a /app-version]

    E --> F[AppVersionScreen]

    subgraph AppVersionScreen ["Pantalla de Actualizaci√≥n"]
        F --> G[Mostrar mensaje de actualizaci√≥n]
        G --> H[Bot√≥n: Actualizar Ahora]
        H --> I[Abrir pisto.co en navegador]
        I --> J[Usuario descarga nueva versi√≥n]
        J --> K[Usuario instala nueva versi√≥n]
        K --> L[Reiniciar app con nueva versi√≥n]
    end

    subgraph AuthFlow ["Flujo de Autenticaci√≥n"]
        M[Usuario hace Login] --> N[AuthNotifier._setAuthenticatedState]
        N --> O[checkVersionFromUserData llamado]
        O --> P[Obtener versi√≥n instalada]
        O --> Q[Recibir serverAppVersion]
        P --> R[Comparar versiones]
        Q --> R
        R -->|Nueva versi√≥n disponible| S[needsUpdate = true]
        R -->|Versiones iguales| T[needsUpdate = false]
        S --> U[AppState.appNeedsUpdate = true]
        T --> V[AppState.appNeedsUpdate = false]
    end

    U --> B
    V --> D
    L --> A

    D --> W[Verificar Onboarding]
    W --> X[Verificar GPS]
    X --> Y[Verificar Auth]
    Y --> Z[Pantalla correspondiente]

    style F fill:#ffcccc
    style S fill:#ffcccc
    style U fill:#ffcccc
```

## 5. Manejo de Errores

### 5.1. Estrategia Actual

La implementaci√≥n actual maneja errores de forma **conservadora**:

```dart
try {
  // Verificaci√≥n de versi√≥n
  final needsUpdate = _isVersionNewer(serverAppVersion, currentVersion);
  state = state.copyWith(needsUpdate: needsUpdate, isLoading: false);
} catch (e) {
  // En caso de error, NO bloquear la app
  state = state.copyWith(
    errorMessage: e.toString(),
    isLoading: false,
    hasBeenChecked: true,
  );
}
```

**Comportamiento con errores**:

-   Si falla la comparaci√≥n de versiones, se permite continuar con el flujo normal
-   No se muestra pantalla de error al usuario
-   Se registra el error en logs para debugging

### 5.2. Diferencias con Requerimientos Originales

**Requerimiento original P1D**: "_En caso de error en la comunicaci√≥n con la API se mostrar√° el error correspondiente_"

**Implementaci√≥n actual**: No hay manejo de errores de UI porque la verificaci√≥n se ejecuta durante el login, donde ya existe manejo de errores de autenticaci√≥n.

## 6. Notas de Implementaci√≥n

### 6.1. Comparaci√≥n Sem√°ntica de Versiones

La aplicaci√≥n implementa comparaci√≥n sem√°ntica personalizada:

```dart
bool _isVersionNewer(String serverVersion, String currentVersion) {
  final serverParts = serverVersion.split('.').map(int.parse).toList();
  final currentParts = currentVersion.split('.').map(int.parse).toList();

  // Compara parte por parte (major.minor.patch)
  for (int i = 0; i < maxLength; i++) {
    if (serverParts[i] > currentParts[i]) return true;
    if (serverParts[i] < currentParts[i]) return false;
  }
  return false; // Son iguales
}
```

### 6.2. Estado Global Integrado

La verificaci√≥n de versi√≥n est√° integrada en el `AppState` global:

```dart
@freezed
abstract class AppState with _$AppState {
  const factory AppState({
    @Default(false) bool appNeedsUpdate,  // üéØ Flag de actualizaci√≥n
    // ... otros estados
  }) = _AppState;
}
```

### 6.3. Prioridad en Middleware

En el `RouteMiddleware`, la verificaci√≥n de versi√≥n tiene **m√°xima prioridad**:

1. ‚úÖ **Verificaci√≥n de versi√≥n** (bloquea todo)
2. Onboarding
3. GPS
4. Autenticaci√≥n
5. Carga de contactos
