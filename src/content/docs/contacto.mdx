---
title: Flujo de contacto
slug: contacto
tags: [auth, flutter, riverpod, dio, formz, go_router, freezed, json_annotation]
description: Flujo de contacto. GestiÃ³n completa del proceso de consulta y respuesta de contacto.
---

## DescripciÃ³n General

La funcionalidad de **Contacto** (`contact`) es el canal oficial de comunicaciÃ³n que permite a los usuarios enviar mensajes, comentarios, dudas y archivos adjuntos directamente al equipo de soporte de Pisto. Este sistema proporciona una interfaz intuitiva y segura para que los usuarios puedan expresar sus inquietudes, reportar problemas, solicitar asistencia o enviar documentaciÃ³n relevante, garantizando que cada mensaje sea entregado correctamente al equipo correspondiente para una respuesta oportuna.

### ğŸ“Š Estructura del Flujo

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MenÃº Principal   â”‚â”€â”€â”€â”€â–¶â”‚ Formulario de     â”‚â”€â”€â”€â”€â–¶â”‚ ComposiciÃ³n de   â”‚â”€â”€â”€â”€â–¶â”‚ EnvÃ­o y          â”‚â”€â”€â”€â”€â–¶â”‚ ConfirmaciÃ³n     â”‚
â”‚ (NavegaciÃ³n)    â”‚     â”‚ Contacto          â”‚     â”‚ Mensaje          â”‚     â”‚ Procesamiento    â”‚     â”‚ (Resultado)      â”‚
â”‚                 â”‚     â”‚                     â”‚     â”‚                     â”‚     â”‚                     â”‚     â”‚                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     âœ“ Acceso rÃ¡pido      âœ“ Campos de texto     âœ“ ValidaciÃ³n          âœ“ API Backend         âœ“ Ã‰xito/Error
```

### âœ¨ CaracterÃ­sticas Principales

-   âœ… **ComunicaciÃ³n directa**: Canal oficial con equipo de soporte
-   âœ… **Adjuntos mÃºltiples**: Soporte para archivos PDF e imÃ¡genes JPG
-   âœ… **ValidaciÃ³n en tiempo real**: VerificaciÃ³n automÃ¡tica del contenido
-   âœ… **Manejo robusto de errores**: RecuperaciÃ³n ante fallos de envÃ­o
-   âœ… **Interfaz intuitiva**: Formulario simple y claro
-   âœ… **ConfirmaciÃ³n inmediata**: Feedback visual del envÃ­o exitoso
-   âœ… **GestiÃ³n de estado**: Persistencia durante el proceso
-   âœ… **Seguridad de datos**: ProtecciÃ³n de informaciÃ³n sensible

---

## GuÃ­a del Usuario

### ğŸ¯ Â¿Para quÃ© sirve el formulario de contacto?

El formulario de contacto te permite:

-   **Enviar dudas**: Preguntas sobre prÃ©stamos, pagos o servicios
-   **Reportar problemas**: Errores tÃ©cnicos o dificultades con la app
-   **Solicitar asistencia**: Ayuda personalizada del equipo de soporte
-   **Enviar documentos**: Archivos relevantes para tu caso
-   **Dar feedback**: Sugerencias para mejorar la plataforma
-   **Consultar estado**: InformaciÃ³n sobre tus solicitudes

### ğŸ“± CÃ³mo usar el formulario de contacto

#### Paso 1: Acceder al formulario de contacto

Para enviar un mensaje al soporte:

**Desde el menÃº principal:**

1. ğŸ  **Abre el menÃº lateral** - Toca el Ã­cono de hamburguesa (â˜°)
2. ğŸ’¬ **Busca "Contacto"** - Encuentra la opciÃ³n en el menÃº
3. ğŸ‘† **Presiona la opciÃ³n** - AccederÃ¡s al formulario de contacto
4. ğŸ“ **Espera la carga** - El formulario aparecerÃ¡ listo para usar

**CaracterÃ­sticas de acceso:**

-   âš¡ **Carga instantÃ¡nea** - El formulario estÃ¡ disponible inmediatamente
-   ğŸ”„ **Sin requerimientos previos** - No necesitas preparaciÃ³n especial
-   ğŸ“± **Disponible siempre** - Accesible desde cualquier pantalla

#### Paso 2: Componer tu mensaje

Una vez en el formulario de contacto:

**RedacciÃ³n del mensaje:**

1. ğŸ‘€ **Identifica el campo de texto** - Ãrea grande para escribir tu mensaje
2. âŒ¨ï¸ **Escribe tu consulta** - SÃ© claro y especÃ­fico en tu descripciÃ³n
3. ğŸ“‹ **Incluye detalles importantes** - Fechas, montos, referencias si aplica
4. âœ… **Revisa tu texto** - AsegÃºrate de que todo estÃ© claro y completo

**Tips para un buen mensaje:**

-   ğŸ¯ **SÃ© especÃ­fico** - Describe exactamente lo que necesitas
-   ğŸ“Š **Incluye contexto** - Menciona cuÃ¡ndo y dÃ³nde ocurre el problema
-   ğŸ”¢ **AÃ±ade datos relevantes** - NÃºmeros de prÃ©stamo, fechas, montos
-   ğŸ“ **Usa lenguaje claro** - Evita jerga tÃ©cnica si no es necesario

#### Paso 3: Adjuntar archivos (opcional)

Si necesitas enviar documentos o evidencias:

**Proceso de adjunto:**

1. ğŸ“ **Busca el botÃ³n de adjuntar** - Generalmente con Ã­cono de clip o papel
2. ğŸ‘† **Presiona el botÃ³n** - Se abrirÃ¡ el selector de archivos
3. ğŸ“ **Selecciona el archivo** - Elige PDF o JPG desde tu dispositivo
4. âœ… **Confirma la selecciÃ³n** - El archivo aparecerÃ¡ adjunto

**Tipos de archivos permitidos:**

-   ğŸ“„ **Documentos PDF** - Contratos, estados de cuenta, identificaciones
-   ğŸ–¼ï¸ **ImÃ¡genes JPG** - Capturas de pantalla, fotos de documentos
-   ğŸ“ **TamaÃ±o limitado** - Archivos optimizados para envÃ­o rÃ¡pido

**Consideraciones de archivos:**

-   ğŸ”’ **Seguridad** - Solo adjunta informaciÃ³n necesaria y relevante
-   ğŸ“Š **Calidad** - AsegÃºrate de que los documentos sean legibles
-   ğŸ¯ **Relevancia** - Adjunta solo archivos relacionados con tu consulta

#### Paso 4: Revisar y enviar

Antes de enviar tu mensaje:

**VerificaciÃ³n final:**

1. ğŸ‘€ **Revisa tu mensaje** - Lee cuidadosamente el texto escrito
2. ğŸ“ **Confirma adjuntos** - Verifica que los archivos correctos estÃ©n adjuntos
3. âœ… **ValidaciÃ³n automÃ¡tica** - El sistema verificarÃ¡ que todo estÃ© completo
4. ğŸš€ **Presiona "Enviar"** - Tu mensaje serÃ¡ procesado

**Indicadores de validaciÃ³n:**

-   âœ… **Campo requerido** - El mensaje no puede estar vacÃ­o
-   ğŸ“ **Longitud mÃ­nima** - Debes incluir suficiente informaciÃ³n
-   ğŸ“ **Archivos vÃ¡lidos** - Solo formatos permitidos
-   ğŸ”„ **Sin errores** - Todo debe estar correcto para enviar

#### Paso 5: ConfirmaciÃ³n del envÃ­o

Una vez enviado tu mensaje:

**ConfirmaciÃ³n inmediata:**

1. ğŸ“± **Pantalla de Ã©xito** - VerÃ¡s un mensaje de confirmaciÃ³n
2. âœ… **NÃºmero de caso** - Tu mensaje serÃ¡ registrado con un ID Ãºnico
3. â° **Tiempo de respuesta** - Se indicarÃ¡ cuÃ¡ndo esperar respuesta
4. ğŸ”„ **OpciÃ³n de continuar** - PodrÃ¡s volver a la aplicaciÃ³n principal

**QuÃ© sucede despuÃ©s:**

-   ğŸ“§ **NotificaciÃ³n al equipo** - Tu mensaje llega inmediatamente al soporte
-   ğŸ“Š **Registro en sistema** - Tu consulta queda documentada
-   â±ï¸ **Procesamiento** - El equipo analizarÃ¡ tu caso
-   ğŸ“ **Respuesta oportuna** - Te contactarÃ¡n segÃºn la prioridad

#### Paso 6: Seguimiento de tu consulta

Para conocer el estado de tu mensaje:

**Opciones de seguimiento:**

-   ğŸ“± **Espera respuesta** - El equipo se comunicarÃ¡ contigo directamente
-   ğŸ“§ **Revisa tu email** - Puedes recibir actualizaciones por correo
-   ğŸ“ **Llamada telefÃ³nica** - Para casos urgentes, te llamarÃ¡n
-   ğŸ”„ **Nuevo mensaje** - Si necesitas aÃ±adir informaciÃ³n, envÃ­a otro formulario

### âš ï¸ InformaciÃ³n importante

**Consideraciones de uso:**

-   ğŸ“‹ **Un mensaje por envÃ­o** - Cada formulario trata un caso especÃ­fico
-   ğŸ”„ **No hay conversaciÃ³n** - Cada envÃ­o es independiente del anterior
-   ğŸ“Š **Tiempo de respuesta** - VarÃ­a segÃºn la complejidad del caso
-   ğŸ”’ **Privacidad protegida** - Tu informaciÃ³n es tratada confidencialmente

**CuÃ¡ndo usar el contacto:**

-   â“ **Dudas generales** - Preguntas sobre servicios y procesos
-   ğŸ› **Problemas tÃ©cnicos** - Errores o dificultades con la app
-   ğŸ“Š **Consultas especÃ­ficas** - InformaciÃ³n sobre tu cuenta o prÃ©stamos
-   ğŸ“ **DocumentaciÃ³n requerida** - EnvÃ­o de archivos para verificaciÃ³n
-   ğŸ’¡ **Sugerencias** - Ideas para mejorar la plataforma

**Alternativas al contacto:**

-   â“ **FAQs** - Para preguntas frecuentes y respuestas inmediatas
-   ğŸ“ **Llamada directa** - Para urgencias que requieren atenciÃ³n inmediata
-   ğŸ“± **Chat en vivo** - Si estÃ¡ disponible, para conversaciones en tiempo real
-   ğŸ¦ **Visita a sucursal** - Para trÃ¡mites presenciales si aplica

---

## Arquitectura TÃ©cnica

### ğŸ—ï¸ Estructura del MÃ³dulo

El mÃ³dulo de contacto sigue una arquitectura limpia con separaciÃ³n clara de responsabilidades:

```
contact/
â”œâ”€â”€ entities/                    # Entidades de dominio
â”‚   â”œâ”€â”€ contact_entity.dart                 # Mensaje de contacto
â”‚   â””â”€â”€ contact_entity.freezed.dart         # CÃ³digo generado
â”œâ”€â”€ models/                      # DTOs para API
â”‚   â”œâ”€â”€ contact_response_dto.dart           # Respuesta del endpoint
â”‚   â””â”€â”€ contact_response_dto.g.dart         # CÃ³digo generado
â”œâ”€â”€ providers/                   # GestiÃ³n de estado
â”‚   â”œâ”€â”€ contact_provider.dart                 # Provider principal
â”‚   â”œâ”€â”€ contact_provider.freezed.dart        # CÃ³digo generado
â”‚   â””â”€â”€ contact_provider.g.dart              # CÃ³digo generado
â”œâ”€â”€ repositories/               # Acceso a datos
â”‚   â”œâ”€â”€ contact_repository.dart              # API de contacto
â”‚   â””â”€â”€ contact_repository.g.dart            # CÃ³digo generado
â””â”€â”€ screens/                    # Interfaces de usuario
    â”œâ”€â”€ contact_form_screen.dart             # Formulario principal
    â””â”€â”€ contact_response_screen.dart         # ConfirmaciÃ³n
```

### ğŸ“Š Entities (Entidades de Dominio)

#### **ContactEntity**

Entidad que representa un mensaje de contacto completo:

```dart
@freezed
abstract class ContactEntity with _$ContactEntity {
  const factory ContactEntity({
    required String message,          // Mensaje del usuario
    @Default('') String successMessage, // Mensaje de Ã©xito del servidor
    File? file,                       // Archivo adjunto (opcional)
    String? fileName,                 // Nombre del archivo adjunto
  }) = _ContactEntity;
}
```

**CaracterÃ­sticas de la entidad:**

-   âœ… **Inmutable**: Usando Freezed para seguridad de datos
-   âœ… **Serializable**: FÃ¡cil conversiÃ³n a/desde JSON
-   âœ… **Validada**: Con validaciones incorporadas
-   âœ… **Extensible**: FÃ¡cil de aÃ±adir nuevos campos

### ğŸ¯ Providers (GestiÃ³n de Estado)

#### **ContactNotifier**

StateNotifier para gestiÃ³n del formulario de contacto:

```dart
@Riverpod(keepAlive: true)
class ContactNotifier extends _$ContactNotifier {
  @override
  ContactState build() {
    return const ContactState();
  }

  /// Actualizar mensaje y validar
  void updateMessage(String value) {
    final message = ContactMessageInput.dirty(value);
    state = state.copyWith(
      message: message,
      isValid: message.isValid,
      errorMessage: '',
    );
  }

  /// Seleccionar archivo (JPG o PDF)
  Future<void> pickFile() async {
    try {
      // Iniciar flujo externo para prevenir refresh de auth durante file picker
      ref.read(externalFlowProvider.notifier).startExternalFlow('/contact');

      final result = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: ['jpg', 'jpeg', 'pdf'],
        compressionQuality: 80,
      );

      // Verificar si el provider sigue montado despuÃ©s del async gap
      if (!ref.mounted) return;

      if (result != null && result.files.single.path != null) {
        final file = File(result.files.single.path!);
        final fileName = result.files.single.name;

        state = state.copyWith(
          file: file,
          fileName: fileName,
          errorMessage: '',
        );
      }

      // Delay antes de ending external flow para asegurar que el evento
      // 'resumed' del app lifecycle se procese primero
      await Future.delayed(const Duration(milliseconds: 500));

      if (!ref.mounted) return;
      ref.read(externalFlowProvider.notifier).endExternalFlow();
    } catch (e) {
      if (!ref.mounted) return;

      state = state.copyWith(
        errorMessage: 'Error al seleccionar archivo: ${e.toString()}',
      );

      await Future.delayed(const Duration(milliseconds: 500));
      if (!ref.mounted) return;
      ref.read(externalFlowProvider.notifier).endExternalFlow();
    }
  }

  /// Remover archivo seleccionado
  void removeFile() {
    state = state.copyWith(file: null, fileName: '');
  }

  /// Enviar formulario
  Future<void> submitForm() async {
    // Validar mensaje
    final message = ContactMessageInput.dirty(state.message.value);

    if (!message.isValid) {
      state = state.copyWith(
        message: message,
        isValid: false,
        errorMessage: message.errorMessage ?? 'El mensaje no es vÃ¡lido',
      );
      return;
    }

    // Establecer estado de carga
    state = state.copyWith(
      isLoading: true,
      errorMessage: '',
      successMessage: '',
      formWasSubmitted: false,
    );

    try {
      final repository = ref.read(contactRepositoryProvider);

      final response = await repository.sendContact(
        message: state.message.value,
        file: state.file,
      );

      // Actualizar estado con Ã©xito
      state = state.copyWith(
        isLoading: false,
        formWasSubmitted: true,
        successMessage: response.message,
        errorMessage: '',
      );
    } on NetworkException catch (e) {
      state = state.copyWith(
        isLoading: false,
        formWasSubmitted: false,
        errorMessage: e.message,
        successMessage: '',
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        formWasSubmitted: false,
        errorMessage: 'Error inesperado: ${e.toString()}',
        successMessage: '',
      );
    }
  }

  /// Resetear formulario
  void resetForm() {
    state = const ContactState();
  }
}

@freezed
abstract class ContactState with _$ContactState {
  const factory ContactState({
    @Default(ContactMessageInput.pure()) ContactMessageInput message,
    File? file,
    @Default('') String fileName,
    @Default(false) bool isLoading,
    @Default(false) bool isValid,
    @Default(false) bool formWasSubmitted,
    @Default('') String errorMessage,
    @Default('') String successMessage,
  }) = _ContactState;

  const ContactState._();

  /// Verificar si el formulario puede ser enviado
  bool get canSubmit => isValid && !isLoading;
}
```

### ğŸŒ Repository (Acceso a Datos)

#### **ContactRepository**

Clase responsable de la comunicaciÃ³n con la API:

```dart
abstract class IContactRepository {
  Future<ContactResponseDto> sendContact({required String message, File? file});
}

class ContactRepository implements IContactRepository {
  final HttpClient _httpClient;

  ContactRepository(this._httpClient);

  @override
  Future<ContactResponseDto> sendContact({
    required String message,
    File? file,
  }) async {
    try {
      // Construir FormData para multipart
      final formData = FormData.fromMap({
        'text': message,
        if (file != null)
          'file': await MultipartFile.fromFile(
            file.path,
            filename: file.path.split('/').last,
          ),
      });

      // Enviar request a /client/contact
      final response = await _httpClient.post<Map<String, dynamic>>(
        '/client/contact',
        data: formData,
      );

      // Parsear respuesta
      if (response.data != null) {
        return ContactResponseDto.fromJson(response.data!);
      } else {
        throw NetworkException(
          message: 'No se recibiÃ³ respuesta del servidor',
          statusCode: response.statusCode,
        );
      }
    } on DioException catch (e) {
      if (e.error is NetworkException) {
        rethrow;
      }

      throw NetworkException(
        message: e.message ?? 'Error al enviar mensaje',
        statusCode: e.response?.statusCode,
      );
    } catch (e) {
      throw NetworkException(message: 'Error inesperado: ${e.toString()}');
    }
  }
}

@riverpod
ContactRepository contactRepository(Ref ref) {
  final httpClient = ref.read(httpClientProvider);
  return ContactRepository(httpClient);
}
```

### ğŸ“± Models (DTOs)

#### **ContactResponseDto**

Modelo para la respuesta del endpoint:

```dart
@JsonSerializable()
class ContactResponseDto {
  final String message;

  ContactResponseDto({
    required this.message,
  });

  factory ContactResponseDto.fromJson(Map<String, dynamic> json) =>
      _$ContactResponseDtoFromJson(json);

  Map<String, dynamic> toJson() => _$ContactResponseDtoToJson(this);
}
```

---

## Flujo Completo de Datos

### ğŸ”„ Flujo de EnvÃ­o de Mensaje

```
AppSidebarLayout (menÃº lateral)
  â†“
ContactFormScreen (formulario principal)
  â†“
ContactNotifier (gestiÃ³n de estado)
  â”œâ”€â†’ updateMessage() (validaciÃ³n en tiempo real)
  â”œâ”€â†’ pickFile() (selecciÃ³n de archivo)
  â””â”€â†’ submitForm() (envÃ­o final)
  â†“
ContactRepository (sendContact)
  â†“
FormData.fromMap() (preparaciÃ³n multipart)
  â”œâ”€â†’ text: message
  â””â”€â†’ file: MultipartFile (si aplica)
  â†“
HttpClient (POST /client/contact)
  â”œâ”€â†’ AutenticaciÃ³n (token JWT)
  â”œâ”€â†’ EnvÃ­o multipart/form-data
  â””â”€â†’ Procesamiento en backend
  â†“
ContactResponseDto (deserializaciÃ³n)
  â†“
ContactNotifier (actualizaciÃ³n de estado)
  â”œâ”€â†’ isLoading: false
  â”œâ”€â†’ formWasSubmitted: true
  â”œâ”€â†’ successMessage: response.message
  â””â”€â†’ errorMessage: ''
  â†“
NavigaciÃ³n automÃ¡tica a ContactResponseScreen
```

### ğŸ”„ Flujo de SelecciÃ³n de Archivo

```
Usuario presiona "Adjuntar archivo"
  â†“
ContactNotifier.pickFile()
  â†“
externalFlowProvider.startExternalFlow('/contact')
  â†“
FilePicker.platform.pickFiles()
  â”œâ”€â†’ type: FileType.custom
  â”œâ”€â†’ allowedExtensions: ['jpg', 'jpeg', 'pdf']
  â””â”€â†’ compressionQuality: 80
  â†“
ValidaciÃ³n de provider montado (ref.mounted)
  â†“
ActualizaciÃ³n de estado con archivo seleccionado
  â†“
Delay de 500ms (para app lifecycle)
  â†“
externalFlowProvider.endExternalFlow()
```

### ğŸ”„ Flujo de Manejo de Errores

```
Error durante envÃ­o (NetworkException, etc.)
  â†“
ContactNotifier.catch block
  â†“
ActualizaciÃ³n de estado de error
  â”œâ”€â†’ isLoading: false
  â”œâ”€â†’ formWasSubmitted: false
  â”œâ”€â†’ errorMessage: e.message
  â””â”€â†’ successMessage: ''
  â†“
SnackBar en ContactFormScreen
  â†“
Delay de 3 segundos
  â†“
resetForm() automÃ¡tico
```

### ğŸ“Š Diagrama de Estados

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ContactNotifier                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Estado: ContactState con keepAlive: true                        â”‚
â”‚                                                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Estados principales:                                            â”‚
â”‚  - initial: Formulario listo para usar                          â”‚
â”‚  - typing: Usuario escribiendo mensaje                         â”‚
â”‚  - fileSelected: Archivo adjunto                                â”‚
â”‚  - submitting: Enviando formulario                             â”‚
â”‚  - success: Mensaje enviado correctamente                      â”‚
â”‚  - error: Error durante el envÃ­o                               â”‚
â”‚                                                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Datos:                                                        â”‚
â”‚  - message: ContactMessageInput (validaciÃ³n)                   â”‚
â”‚  - file: File? (archivo adjunto)                               â”‚
â”‚  - fileName: String (nombre del archivo)                       â”‚
â”‚  - isValid: bool (formulario vÃ¡lido)                           â”‚
â”‚  - isLoading: bool (estado de envÃ­o)                           â”‚
â”‚  - formWasSubmitted: bool (envÃ­o completado)                   â”‚
â”‚  - errorMessage: String (mensaje de error)                     â”‚
â”‚  - successMessage: String (mensaje de Ã©xito)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Acciones:                                                     â”‚
â”‚  - updateMessage(): ValidaciÃ³n en tiempo real                  â”‚
â”‚  - pickFile(): SelecciÃ³n de archivo con seguridad              â”‚
â”‚  - removeFile(): Eliminar archivo seleccionado                 â”‚
â”‚  - submitForm(): EnvÃ­o completo a backend                      â”‚
â”‚  - resetForm(): Reiniciar formulario                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Componentes y Pasos

### ğŸ“± Pantallas del Flujo

#### 1. ğŸ“ ContactFormScreen

-   **Ruta**: `/contact`
-   **PropÃ³sito**: Formulario principal para enviar mensajes
-   **Funcionalidad**:
    -   Campo de texto para mensaje con validaciÃ³n en tiempo real
    -   Selector de archivos para adjuntar PDF o JPG
    -   Indicadores visuales de estado y validaciÃ³n
    -   NavegaciÃ³n automÃ¡tica a pantalla de Ã©xito
    -   Manejo de errores con SnackBar

**Componentes principales:**

```dart
class ContactFormScreen extends ConsumerStatefulWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final contactState = ref.watch(contactProvider);

    // Escuchar cambios de estado para navegaciÃ³n
    ref.listen(contactProvider, (previous, next) {
      // Navegar a pantalla de respuesta en Ã©xito
      if (next.formWasSubmitted &&
          next.successMessage.isNotEmpty &&
          next.errorMessage.isEmpty) {
        context.pushReplacement('/contact-response');
      }

      // Mostrar mensaje de error
      if (next.errorMessage.isNotEmpty && !next.isLoading) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(next.errorMessage),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 3),
          ),
        );
      }
    });

    return AppLayout(
      title: 'Contacto',
      child: Column(
        children: [
          // Instrucciones
          const Text(
            'Escribe tu comentario y te contactaremos a la mayor brevedad posible',
          ),

          // Campo de mensaje
          TextFormField(
            controller: _messageController,
            autofocus: true,
            maxLines: 8,
            decoration: InputDecoration(
              hintText: 'Describe tu duda o problema...',
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(8.0),
              ),
            ),
            onChanged: (value) {
              ref.read(contactProvider.notifier).updateMessage(value);
            },
          ),

          // Selector de archivo
          if (contactState.file != null)
            _buildSelectedFileWidget(contactState)
          else
            _buildFilePickerButton(),

          // BotÃ³n de envÃ­o
          PrimaryBtn(
            text: 'Enviar mensaje',
            onPressed: contactState.canSubmit
                ? () => ref.read(contactProvider.notifier).submitForm()
                : null,
            isLoading: contactState.isLoading,
          ),
        ],
      ),
    );
  }
}
```

#### **\_buildSelectedFileWidget()**

Widget para mostrar archivo adjunto:

```dart
Widget _buildSelectedFileWidget(ContactState state) {
  return Container(
    padding: const EdgeInsets.all(12),
    decoration: BoxDecoration(
      border: Border.all(color: AppTheme.primary),
      borderRadius: BorderRadius.circular(8),
    ),
    child: Row(
      children: [
        const Icon(Icons.attach_file, color: AppTheme.primary),
        const SizedBox(width: 8),
        Expanded(
          child: Text(
            state.fileName,
            style: const TextStyle(color: AppTheme.primary),
          ),
        ),
        IconButton(
          icon: const Icon(Icons.close, color: AppTheme.negative),
          onPressed: () => ref.read(contactProvider.notifier).removeFile(),
        ),
      ],
    ),
  );
}
```

#### **\_buildFilePickerButton()**

BotÃ³n para seleccionar archivo:

```dart
Widget _buildFilePickerButton() {
  return OutlinedBtn(
    text: 'Adjuntar archivo (PDF o JPG)',
    onPressed: () => ref.read(contactProvider.notifier).pickFile(),
    prefixIcon: const Icon(Icons.attach_file),
  );
}
```

#### 2. âœ… ContactResponseScreen

-   **Ruta**: `/contact-response`
-   **PropÃ³sito**: Pantalla de confirmaciÃ³n de envÃ­o exitoso
-   **Funcionalidad**:
    -   Mensaje de Ã©xito claro y visible
    -   Icono de confirmaciÃ³n visual
    -   InformaciÃ³n sobre prÃ³ximos pasos
    -   BotÃ³n para continuar a la aplicaciÃ³n

**Componentes principales:**

```dart
class ContactResponseScreen extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final contactState = ref.watch(contactProvider);

    return AppLayout(
      title: 'Contacto',
      child: Column(
        children: [
          // Ãcono de Ã©xito
          Container(
            width: 80,
            height: 80,
            decoration: BoxDecoration(
              color: AppTheme.correct.withValues(alpha: 0.1),
              shape: BoxShape.circle,
            ),
            child: const Icon(
              Icons.check_circle_outline,
              color: AppTheme.correct,
              size: 50,
            ),
          ),

          // Mensaje de Ã©xito
          Text(
            contactState.successMessage.isNotEmpty
                ? contactState.successMessage
                : 'Â¡Tu mensaje ha sido enviado exitosamente!',
            style: const TextStyle(
              color: AppTheme.correct,
              fontSize: 20,
              fontWeight: FontWeight.w700,
            ),
            textAlign: TextAlign.center,
          ),

          // InformaciÃ³n adicional
          Text(
            'Te contactaremos a la mayor brevedad posible.',
            style: TextStyle(
              color: AppTheme.darkBlue.withValues(alpha: 0.7),
              fontSize: 16,
            ),
            textAlign: TextAlign.center,
          ),

          // BotÃ³n de continuar
          PrimaryBtn(
            text: 'Continuar',
            onPressed: () {
              ref.read(contactProvider.notifier).resetForm();
              context.go('/my-loan');
            },
          ),
        ],
      ),
    );
  }
}
```

---

## APIs Utilizadas

### ğŸ“¡ Endpoints de API

#### **POST** `/client/contact`

**PropÃ³sito**: Enviar mensaje de contacto con archivo adjunto opcional

**Headers Requeridos**:

```http
POST /client/contact HTTP/1.1
Host: api.pisto.co
Authorization: Bearer {jwt_token}
Content-Type: multipart/form-data
X-Client-Version: 1.0.0
X-Device-ID: {device_identifier}
```

**Request Body (multipart/form-data)**:

```
------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="text"

Escribo para reportar un problema con mi prÃ©stamo #12345. El sistema no me permite realizar el pago programado para hoy.
------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="file"; filename="comprobante.jpg"
Content-Type: image/jpeg

[Binary file data]
------WebKitFormBoundary7MA4YWxkTrZu0gW--
```

**Response Exitoso (200)**:

```json
{
    "message": "Tu mensaje ha sido recibido. Te contactaremos dentro de 24 horas."
}
```

**Error 422 (ValidaciÃ³n)**:

```json
{
    "errors": [
        {
            "message": "El mensaje no puede estar vacÃ­o"
        }
    ]
}
```

**Error 413 (Archivo muy grande)**:

```json
{
    "errors": [
        {
            "message": "El archivo excede el tamaÃ±o mÃ¡ximo permitido (5MB)"
        }
    ]
}
```

**Error 401 (Unauthorized)**:

```json
{
    "message": "Usuario no autenticado"
}
```

### ğŸ”’ CaracterÃ­sticas de la API

-   **AutenticaciÃ³n requerida**: Solo usuarios autenticados pueden enviar mensajes
-   **Multipart support**: Manejo de archivos adjuntos
-   **ValidaciÃ³n de contenido**: VerificaciÃ³n de formato y tamaÃ±o
-   **Respuesta inmediata**: ConfirmaciÃ³n de recepciÃ³n del mensaje
-   **Rate limiting**: PrevenciÃ³n de abusos y spam

---

## Manejo de Errores

### âš ï¸ Tipos de Errores

#### **1. Errores de ValidaciÃ³n**

```dart
// Mensaje vacÃ­o
EmptyMessageException {
  message: "El mensaje no puede estar vacÃ­o",
  suggestion: "Por favor, describe tu duda o problema",
}

// Mensaje muy corto
TooShortMessageException {
  message: "El mensaje es demasiado corto",
  minLength: 10,
  suggestion: "Proporciona mÃ¡s detalles sobre tu consulta",
}

// Archivo no permitido
InvalidFileException {
  message: "Tipo de archivo no permitido",
  allowedTypes: ["PDF", "JPG", "JPEG"],
  suggestion: "Selecciona un archivo PDF o imagen JPG",
}
```

#### **2. Errores de Archivo**

```dart
// Archivo muy grande
FileTooLargeException {
  message: "El archivo excede el tamaÃ±o mÃ¡ximo permitido",
  maxSize: "5MB",
  currentSize: "8.2MB",
  suggestion: "Comprime el archivo o selecciona uno mÃ¡s pequeÃ±o",
}

// Error al seleccionar archivo
FilePickerException {
  message: "Error al seleccionar archivo",
  details: "Permiso denegado o archivo corrupto",
  canRetry: true,
}
```

#### **3. Errores de Conectividad**

```dart
// Error de red
NetworkException {
  message: "Error de conexiÃ³n. Verifica tu conectividad.",
  canRetry: true,
  retryCallback: () => ref.refresh(contactProvider),
}

// Timeout
TimeoutException {
  message: "Tiempo de espera agotado. Intente nuevamente.",
  canRetry: true,
  retryDelay: Duration(seconds: 5),
}
```

#### **4. Errores del Servidor**

```dart
// Error interno
ServerException {
  message: "Error temporal del servidor. Intente mÃ¡s tarde.",
  canRetry: true,
  retryAfter: 300, // 5 minutos
}

// Servicio no disponible
ServiceUnavailableException {
  message: "Servicio de contacto temporalmente no disponible",
  canRetry: true,
  retryAfter: 600, // 10 minutos
}
```

### ğŸ”„ Estrategias de RecuperaciÃ³n

#### **Reintentos AutomÃ¡ticos**

```dart
class ContactRetryStrategy {
  static const int maxRetries = 3;
  static const Duration baseDelay = Duration(seconds: 2);

  static Future<ContactResponseDto> retryWithBackoff(
    Future<ContactResponseDto> Function() sendCall,
  ) async {
    for (int attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await sendCall();
      } catch (e) {
        if (attempt == maxRetries) rethrow;

        final delay = baseDelay * math.pow(2, attempt - 1);
        await Future.delayed(delay);
      }
    }
    throw ContactException(
      'No se pudo enviar el mensaje despuÃ©s de $maxRetries intentos',
    );
  }
}
```

#### **Fallback para Usuario**

-   **BotÃ³n de reintentar manual** en pantalla de error
-   **Indicador claro del problema** con mensaje especÃ­fico
-   **OpciÃ³n de guardar borrador** para continuar mÃ¡s tarde
-   **Contacto alternativo** si el formulario no funciona

---

## Validaciones

### âœ… Validaciones Implementadas

1. **ValidaciÃ³n de Mensaje**

    - El mensaje no puede estar vacÃ­o
    - Longitud mÃ­nima de 10 caracteres
    - Longitud mÃ¡xima de 2000 caracteres
    - Sin caracteres peligrosos (sanitizaciÃ³n)

2. **ValidaciÃ³n de Archivo**

    - Solo formatos permitidos: PDF, JPG, JPEG
    - TamaÃ±o mÃ¡ximo: 5MB
    - Archivo no corrupto
    - Nombre de archivo vÃ¡lido

3. **ValidaciÃ³n de Formulario**
    - Mensaje requerido y vÃ¡lido
    - Archivo opcional pero validado si presente
    - Estado de envÃ­o controlado
    - PrevenciÃ³n de envÃ­os duplicados

### ğŸ” LÃ³gica de ValidaciÃ³n

#### **ValidaciÃ³n de Mensaje**

```dart
class ContactMessageValidator {
  static ContactMessageValidationError? validate(String value) {
    if (value.isEmpty) {
      return ContactMessageValidationError.empty;
    }

    if (value.trim().length < 10) {
      return ContactMessageValidationError.tooShort;
    }

    if (value.length > 2000) {
      return ContactMessageValidationError.tooLong;
    }

    // SanitizaciÃ³n bÃ¡sica
    if (_containsDangerousContent(value)) {
      return ContactMessageValidationError.unsafeContent;
    }

    return null; // VÃ¡lido
  }

  static bool _containsDangerousContent(String content) {
    final dangerousPatterns = [
      RegExp(r'<script[^>]*>.*?</script>', caseSensitive: false),
      RegExp(r'javascript:', caseSensitive: false),
      RegExp(r'on\w+\s*=', caseSensitive: false),
    ];

    return dangerousPatterns.any((pattern) => pattern.hasMatch(content));
  }
}
```

#### **ValidaciÃ³n de Archivo**

```dart
class FileValidator {
  static FileValidationError? validate(File? file) {
    if (file == null) return null; // Archivo opcional

    // Validar tamaÃ±o
    final fileSize = file.lengthSync();
    if (fileSize > 5 * 1024 * 1024) { // 5MB
      return FileValidationError.tooLarge;
    }

    // Validar extensiÃ³n
    final fileName = file.path.toLowerCase();
    final allowedExtensions = ['.pdf', '.jpg', '.jpeg'];

    if (!allowedExtensions.any((ext) => fileName.endsWith(ext))) {
      return FileValidationError.invalidType;
    }

    // Validar que el archivo existe y es legible
    if (!file.existsSync()) {
      return FileValidationError.notFound;
    }

    return null; // VÃ¡lido
  }

  static String formatFileSize(int bytes) {
    if (bytes < 1024) return '$bytes B';
    if (bytes < 1024 * 1024) return '${(bytes / 1024).toStringAsFixed(1)} KB';
    return '${(bytes / (1024 * 1024)).toStringAsFixed(1)} MB';
  }
}
```

### ğŸ›¡ï¸ Consideraciones de Seguridad

-   SanitizaciÃ³n de contenido para prevenir XSS
-   ValidaciÃ³n de tipos de archivo para prevenir malware
-   LÃ­mites de tamaÃ±o para prevenir ataques DoS
-   Rate limiting para prevenir spam
-   AutenticaciÃ³n obligatoria para todos los envÃ­os

---

## Testing

### ğŸ§ª Estrategia de Testing

#### **1. Unit Tests**

```dart
// test/unit/contact_test.dart
void main() {
  group('ContactNotifier', () {
    test('debe validar mensaje correctamente', () {
      // Test de validaciÃ³n de mensaje
    });

    test('debe manejar archivo adjunto', () {
      // Test de selecciÃ³n y remociÃ³n de archivo
    });

    test('debe manejar error de envÃ­o', () {
      // Test de manejo de NetworkException
    });
  });

  group('ContactRepository', () {
    test('debe enviar mensaje sin archivo', () {
      // Test de envÃ­o simple
    });

    test('debe enviar mensaje con archivo', () {
      // Test de envÃ­o con adjunto
    });

    test('debe manejar error de API', () {
      // Test de manejo de errores HTTP
    });
  });
}
```

#### **2. Widget Tests**

```dart
// test/widget/contact_form_screen_test.dart
void main() {
  testWidgets('debe mostrar error con mensaje vacÃ­o', (tester) async {
    // Test de validaciÃ³n visual
  });

  testWidgets('debe permitir adjuntar archivo', (tester) async {
    // Test de selecciÃ³n de archivo
  });

  testWidgets('debe mostrar loading durante envÃ­o', (tester) async {
    // Test de estado de carga
  });
}
```

#### **3. Integration Tests**

```dart
// test/integration/contact_flow_test.dart
void main() {
  integrationTest('flujo completo de contacto', () async {
    // Simular: menÃº â†’ formulario â†’ mensaje â†’ archivo â†’ envÃ­o â†’ Ã©xito
  });

  integrationTest('manejo de errores de red', () async {
    // Test de recuperaciÃ³n ante fallos
  });
}
```

### ğŸ“‹ Casos de Prueba CrÃ­ticos

#### **Flujos de Usuario**

-   âœ… Usuario envÃ­a mensaje exitosamente sin archivo
-   âœ… Usuario envÃ­a mensaje con archivo PDF adjunto
-   âœ… Usuario envÃ­a mensaje con imagen JPG adjunta
-   âœ… Usuario maneja error de mensaje vacÃ­o
-   âœ… Usuario remueve archivo seleccionado
-   âœ… Usuario navega a pantalla de Ã©xito despuÃ©s del envÃ­o

#### **Casos LÃ­mite**

-   ğŸ”„ Mensaje con longitud mÃ¡xima permitida
-   ğŸ”„ Archivo justo en el lÃ­mite de tamaÃ±o
-   ğŸ”„ Archivo con formato no permitido
-   ğŸ”„ ConexiÃ³n intermitente durante envÃ­o
-   ğŸ”„ MÃºltiples intentos de envÃ­o fallidos

### ğŸ“Š MÃ©tricas de Testing

-   **Cobertura mÃ­nima**: 85% para lÃ³gica de negocio
-   **Tests de validaciÃ³n**: 100% de reglas de validaciÃ³n
-   **Tests de error**: Todos los tipos de error cubiertos
-   **Tests de UI**: Interacciones crÃ­ticas del usuario

---

## Seguridad

### ğŸ”’ CaracterÃ­sticas de Seguridad

#### **1. ProtecciÃ³n de Datos**

-   âœ… **AutenticaciÃ³n obligatoria**: Solo usuarios validados
-   âœ… **SanitizaciÃ³n de contenido**: PrevenciÃ³n de XSS
-   âœ… **ValidaciÃ³n de archivos**: Tipos y tamaÃ±os seguros
-   âœ… **EncriptaciÃ³n en trÃ¡nsito**: Todos los datos viajan por HTTPS

#### **2. Control de Acceso**

-   âœ… **ValidaciÃ³n de sesiÃ³n**: Token JWT requerido
-   âœ… **Rate limiting**: LÃ­mite de mensajes por tiempo
-   âœ… **AuditorÃ­a completa**: Registro de todos los envÃ­os
-   âœ… **PrevenciÃ³n de spam**: Filtros y validaciones

#### **3. Validaciones de Seguridad**

```dart
class ContactSecurityValidator {
  static bool canSendMessage(UserEntity user) {
    // Validar que el usuario estÃ¡ autenticado
    if (user.id == null) return false;

    // Validar que no hay envÃ­os sospechosos recientes
    if (_hasRecentSuspiciousActivity(user)) return false;

    return true;
  }

  static String sanitizeMessage(String message) {
    // Remover contenido peligroso
    return message
        .replaceAll(RegExp(r'<[^>]*>'), '') // Remove HTML tags
        .replaceAll(RegExp(r'javascript:'), '') // Remove JS protocols
        .replaceAll(RegExp(r'on\w+\s*='), '') // Remove event handlers
        .trim();
  }

  static bool isFileTypeAllowed(String fileName) {
    final allowedTypes = ['.pdf', '.jpg', '.jpeg'];
    final extension = fileName.toLowerCase().split('.').last;
    return allowedTypes.contains('.$extension');
  }
}
```

### ğŸ›¡ï¸ Consideraciones de Privacidad

-   Los mensajes son tratados como informaciÃ³n confidencial
-   Los archivos adjuntos se procesan de forma segura
-   AuditorÃ­a completa para cumplimiento normativo
-   EliminaciÃ³n segura de datos temporales

### ğŸ” Best Practices Implementadas

```dart
// Ejemplo de implementaciÃ³n segura
class SecureContactService {
  Future<ContactResponseDto> sendSecureMessage(
    String message,
    File? file,
    UserContext user,
  ) async {
    try {
      // 1. Validar autenticaciÃ³n
      if (!_securityValidator.canSendMessage(user)) {
        throw UnauthorizedException('Usuario no autorizado');
      }

      // 2. Sanitizar contenido
      final sanitizedMessage = _securityValidator.sanitizeMessage(message);

      // 3. Validar archivo si existe
      if (file != null && !_securityValidator.isFileTypeAllowed(file.path)) {
        throw InvalidFileException('Tipo de archivo no permitido');
      }

      // 4. Enviar de forma segura
      final result = await _repository.sendContact(
        message: sanitizedMessage,
        file: file,
      );

      // 5. Registrar para auditorÃ­a
      _auditLogger.logContactMessage(user.id, sanitizedMessage, file != null);

      return result;
    } catch (e) {
      _auditLogger.logContactError(user.id, e);
      throw SecureContactException.fromError(e);
    }
  }
}
```

---

## ğŸš€ ImplementaciÃ³n y Mantenimiento

### ğŸ“¦ Dependencias Clave

```yaml
dependencies:
    flutter_riverpod: ^2.4.0 # GestiÃ³n de estado
    file_picker: ^6.0.0 # SelecciÃ³n de archivos
    dio: ^5.3.0 # Cliente HTTP
    freezed_annotation: ^2.4.0 # Modelos inmutables
    json_annotation: ^4.8.0 # SerializaciÃ³n JSON

dev_dependencies:
    riverpod_generator: ^2.3.0 # Code generation
    freezed: ^2.4.0 # GeneraciÃ³n de modelos
    json_serializable: ^6.7.0 # GeneraciÃ³n JSON
    build_runner: ^2.4.0 # Herramienta de generaciÃ³n
```

### ğŸ”§ Comandos de Desarrollo

```bash
# Generar cÃ³digo (requerido despuÃ©s de cambios)
dart run build_runner build --delete-conflicting-outputs

# Modo watch durante desarrollo
dart run build_runner watch -d

# Ejecutar pruebas
flutter test test/features/contact/

# AnÃ¡lisis estÃ¡tico
flutter analyze lib/features/contact/
```

### ğŸ“ Mejores PrÃ¡cticas

1. **Code Generation**: Siempre ejecutar `build_runner` despuÃ©s de modificar modelos o providers
2. **State Management**: Usar `keepAlive: true` para persistencia durante selecciÃ³n de archivos
3. **External Flow**: Prevenir refresh de autenticaciÃ³n durante file picker
4. **Validation**: ValidaciÃ³n local y backend para mejor UX
5. **Error Handling**: Manejo especÃ­fico para cada tipo de error
6. **Security**: SanitizaciÃ³n de contenido y validaciÃ³n de archivos

---

## ğŸ”— Integraciones

### ğŸ“„ MÃ³dulos que utilizan Contact

#### **AppSidebarLayout**

-   Acceso desde menÃº lateral de navegaciÃ³n
-   IntegraciÃ³n con navegaciÃ³n principal

#### **Router**

-   Rutas `/contact` y `/contact-response` registradas
-   NavegaciÃ³n automÃ¡tica entre pantallas

#### **HttpClient**

-   ComparticiÃ³n de configuraciÃ³n de red
-   Interceptores de autenticaciÃ³n y errores

#### **ExternalFlowProvider**

-   Manejo del ciclo de vida durante file picker
-   PrevenciÃ³n de redirecciones no deseadas

#### **FilePicker**

-   SelecciÃ³n nativa de archivos del dispositivo
-   Soporte para formatos especÃ­ficos

### ğŸ”„ Flujo de Datos

```
AppSidebarLayout
  â†“
ContactFormScreen
  â†“
ContactNotifier
  â†“
ContactRepository
  â†“
HttpClient
  â†“
API Backend (/client/contact)
  â†“
ContactResponseDto
  â†“
ContactResponseScreen
```
