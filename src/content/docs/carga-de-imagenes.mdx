---
title: Flujo de Carga de ImÃ¡genes
slug: carga-de-imagenes
tags: [auth, image-upload, flutter, riverpod, dio, formz]
description: Flujo de carga de imÃ¡genes. Incluye selecciÃ³n de imÃ¡genes, previsualizaciÃ³n y manejo de errores y estados del proceso.
---

## DescripciÃ³n General

La funcionalidad de **Carga de ImÃ¡genes** es un componente fundamental en el proceso de verificaciÃ³n de identidad para Pisto. Esta funcionalidad permite a los usuarios capturar y cargar tres tipos de imÃ¡genes requeridas durante la solicitud del primer prÃ©stamo y prÃ©stamos posteriores:

1. **Frente del DUI** (Documento Ãšnico de Identidad)
2. **RevÃ©s del DUI**
3. **Selfie con DUI** (foto del usuario sosteniendo el DUI)

### CaracterÃ­sticas Principales

-   âœ… **Captura desde cÃ¡mara**: Utiliza la cÃ¡mara del dispositivo del usuario
-   âœ… **CompresiÃ³n automÃ¡tica**: Reduce tamaÃ±o manteniendo calidad (50% de calidad)
-   âœ… **Upload multipart**: Carga de archivos con FormData
-   âœ… **ValidaciÃ³n de tipos**: Verifica que sea imagen vÃ¡lida
-   âœ… **Indicador de progreso**: Muestra estado de carga
-   âœ… **Reintentos**: Permite reintentar en caso de error
-   âœ… **Almacenamiento de URLs**: Persiste las URLs retornadas por API
-   âœ… **Reutilizable**: Mismo flujo en primer y posteriores prÃ©stamos
-   âœ… **Manejo de errores especÃ­ficos**: Diferentes mensajes segÃºn error

---

## GuÃ­a del Usuario

### ğŸ¯ Â¿Para quÃ© sirve?

La carga de imÃ¡genes valida tu identidad:

-   **Verificamos que eres tÃº**: Comparamos tu selfie con el DUI
-   **Documento vÃ¡lido**: Aseguramos que sea documento oficial
-   **Legibilidad**: Nos permite leer claramente tus datos
-   **Cumplimiento**: Requisito regulatorio para prÃ©stamos

### ğŸ“¸ Pasos para cargar tus imÃ¡genes

#### Paso 1: Prepararse para las fotos

**Antes de empezar:**

-   ColÃ³cate en un lugar bien iluminado
-   AsegÃºrate de tener luz natural o artificial buena
-   Ten tu DUI/carnet a mano
-   AsegÃºrate de tener baterÃ­a en tu dispositivo

#### Paso 2: Capturar Frente del DUI

1. Presiona **"Capturar frente del DUI"**
2. Se abrirÃ¡ la cÃ¡mara del dispositivo
3. Posiciona el DUI de frente, con todos los datos visibles
4. AsegÃºrate de que:
    - La foto sea clara y nÃ­tida
    - Toda la informaciÃ³n sea legible
    - No hay sombras o reflejos
5. Toma la foto
6. El sistema procesarÃ¡ y comprimirÃ¡ la imagen
7. VerÃ¡s "â³ Cargando..." mientras se sube
8. ConfirmaciÃ³n: âœ… Imagen cargada

**Consejos:**

-   Usa zoom para que el DUI ocupe toda la pantalla
-   Evita Ã¡ngulos muy inclinados
-   AsegÃºrate de que los nÃºmeros sean legibles
-   Si no estÃ¡ bien, puedes capturar de nuevo

#### Paso 3: Capturar RevÃ©s del DUI

1. Presiona **"Capturar revÃ©s del DUI"**
2. Da vuelta tu DUI mostrando el lado posterior
3. Sigue los mismos consejos del paso anterior
4. Toma la foto cuando estÃ© clara

#### Paso 4: Capturar Selfie con DUI

1. Presiona **"Capturar selfie con DUI"**
2. Saca una foto tuya sosteniendo el DUI
3. Requisitos para que se acepte:
    - Tu cara debe ser claramente visible
    - Tu DUI debe verse claramente en la foto
    - Ambos deben aparecer en la misma imagen
    - Tu expresiÃ³n facial natural (no necesita sonreÃ­r)

**Consejos para selfie:**

-   Extiende el brazo lo suficiente para que se vea todo
-   Busca iluminaciÃ³n frontal (luz frente a tu cara)
-   Evita sombras en tu rostro
-   AsegÃºrate de que el DUI sea legible

#### Paso 5: RevisiÃ³n y ConfirmaciÃ³n

Una vez cargadas las 3 imÃ¡genes:

-   Todas mostrarÃ¡n estado âœ…
-   PodrÃ¡s ver previsualizaciones (opcional)
-   Presiona **"Continuar"** para siguiente paso
-   O **"Cambiar imÃ¡genes"** si necesitas recapturar

### âš ï¸ Importante

-   **LÃ­mite de tamaÃ±o**: MÃ¡ximo 5MB por imagen (se comprime automÃ¡ticamente)
-   **Formatos**: JPEG, PNG (se convierten automÃ¡ticamente)
-   **Tiempo de espera**: Espera a que aparezca âœ… antes de continuar
-   **ConexiÃ³n**: Necesitas conexiÃ³n a internet (WiFi o datos mÃ³viles)
-   **Reintentos**: Si falla, puedes capturar de nuevo sin limite
-   **Privacidad**: Tus imÃ¡genes se protegen con HTTPS
-   **Datos**: El sistema no guarda las imÃ¡genes, solo valida

---

## Arquitectura TÃ©cnica

### ğŸ—ï¸ PatrÃ³n de Arquitectura

La funcionalidad sigue una arquitectura **Feature-Based** con separaciÃ³n clara:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Presentation Layer (UI)                     â”‚
â”‚  FirstLoanStepFiveScreen / SubsequentLoanStepThreeScreen â”‚
â”‚  + ImageCaptureWidget                          â”‚
â”‚  + ImagePreviewWidget                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    State Management Layer                     â”‚
â”‚  FirstLoanStepFiveNotifier (Riverpod)         â”‚
â”‚  SubsequentLoanStepThreeNotifier              â”‚
â”‚  ImageUploadState (Freezed)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Repository Layer                           â”‚
â”‚  ImageUploadRepository                        â”‚
â”‚  SubsequentImageUploadRepository              â”‚
â”‚  Manejo de errores                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Local Layer                                â”‚
â”‚  ImagePicker (Camera)                         â”‚
â”‚  File system                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Data Layer (API)                           â”‚
â”‚  HttpClient provider                          â”‚
â”‚  /client/upload-images endpoint               â”‚
â”‚  FormData multipart                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ§© Estructura de Directorios

```
ğŸ“ lib/features/first_loan/
â”œâ”€â”€ entities/
â”‚   â”œâ”€â”€ image_type_enum.dart          # Enum de tipos
â”‚   â””â”€â”€ first_loan_request.dart       # Modelo de solicitud
â”‚
â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ image_upload_request.dart     # DTO request
â”‚   â”œâ”€â”€ image_upload_response.dart    # DTO response
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ providers/
â”‚   â”œâ”€â”€ first_loan_step_five_provider.dart  # Step 5 (imÃ¡genes)
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ repositories/
â”‚   â”œâ”€â”€ image_upload_repository.dart  # Repository
â”‚   â””â”€â”€ ...
â”‚
â””â”€â”€ screens/
    â”œâ”€â”€ first_loan_step_five_screen.dart
    â””â”€â”€ widgets/
        â”œâ”€â”€ image_capture_widget.dart
        â””â”€â”€ image_preview_widget.dart

ğŸ“ lib/features/subsequent_loan/
â”œâ”€â”€ entities/
â”‚   â”œâ”€â”€ image_type_enum.dart
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ repositories/
â”‚   â”œâ”€â”€ subsequent_image_upload_repository.dart
â”‚   â””â”€â”€ ...
â”‚
â””â”€â”€ screens/
    â””â”€â”€ subsequent_loan_step_three_screen.dart
```

### ğŸ”„ Flujo de ReutilizaciÃ³n

```
ImageUploadRepository (Compartido en ambos)
         â†‘
         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â”‚          â”‚
First Loan    Subsequent Loan
Step 5        Step 3
```

---

## Flujo de Datos

### ğŸ”„ Flujo Principal: Captura y Carga

#### Fase 1: Seleccionar Capturar Imagen

```
1. Usuario presiona "Capturar [tipo de imagen]"
   â”‚
2. ImagePicker.pickImage(
     source: ImageSource.camera,
     imageQuality: 50,
   )
   â”‚
   â”œâ”€> Se abre la cÃ¡mara del dispositivo
   â”‚   â”‚
   â”‚   â”œâ”€> Usuario toma la foto
   â”‚   â”‚
   â”‚   â””â”€> Selecciona usar foto
   â”‚
3. XFile? image = result
   â”‚
   â””â”€> Â¿Imagen seleccionada?
       â”œâ”€> NO: Retornar (usuario cancelÃ³)
       â””â”€> SI: Continuar
```

#### Fase 2: Preparar Carga

```
1. _updateImageState(
     imageType,
     isUploading: true,
     localImagePath: image.path,
   )
   â”‚
   â”œâ”€> state.status = uploading
   â”œâ”€> Mostrar indicador â³
   â”‚
2. Preparar FormData:
   â”‚
   â”œâ”€> FormData.fromMap({
   â”‚     'imageType': imageType.apiValue,  // 'frontIdCard'
   â”‚     'imageFile': MultipartFile.fromFile(
   â”‚       file.path,
   â”‚       filename: fileName,
   â”‚     ),
   â”‚   })
```

#### Fase 3: Enviar Archivo

```
1. ImageUploadRepository.uploadImage(
     imagePath: image.path,
     imageType: imageType,
   )
   â”‚
2. HttpClient.post(
     '/client/upload-images',
     data: FormData,
   )
   â”‚
   â”œâ”€> Request headers:
   â”‚   â”œâ”€> Content-Type: multipart/form-data
   â”‚   â”œâ”€> Authorization: Bearer <token>
   â”‚   â””â”€> Language: es
   â”‚
3. Â¿Respuesta exitosa (200)?
   â”‚
   â”œâ”€> SI:
   â”‚   â”œâ”€> Response: { "data": { "imageUrl": "https://..." } }
   â”‚   â”‚
   â”‚   â””â”€> ImageUploadResponse.fromJson()
   â”‚
   â””â”€> NO: Lanzar ImageUploadException
```

#### Fase 4: Actualizar Estado

```
1. Â¿Carga exitosa?
   â”‚
   â”œâ”€> SI:
   â”‚   â”œâ”€> _updateImageState(
   â”‚   â”‚     imageType,
   â”‚   â”‚     isUploading: false,
   â”‚   â”‚     imageUrl: response.imageUrl,
   â”‚   â”‚     localImagePath: image.path,
   â”‚   â”‚   )
   â”‚   â”‚
   â”‚   â”œâ”€> state.status = loaded âœ…
   â”‚   â”‚
   â”‚   â””â”€> _updateValidation()
   â”‚       â””â”€> Â¿Todas las 3 imÃ¡genes?
   â”‚           â”œâ”€> SI: isValid = true
   â”‚           â””â”€> NO: isValid = false
   â”‚
   â””â”€> NO:
       â”œâ”€> _updateImageState(
       â”‚     imageType,
       â”‚     isUploading: false,
       â”‚     errorMessage: e.message,
       â”‚   )
       â”‚
       â””â”€> state.status = error
           â””â”€> Mostrar mensaje de error
```

### ğŸ“Š Diagrama de Estados por Imagen

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         ImageUploadState (por cada imagen)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Initial State:
  isUploading: false
  imageUrl: null
  localImagePath: null
  errorMessage: ''

        â†“

[Usuario presiona capturar]
        â†“

Uploading State:
  isUploading: true
  localImagePath: '/path/to/image.jpg'
  errorMessage: ''
  (Mostrar: â³ Cargando...)

        â†“
   â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
   â”‚          â”‚
  SI         NO
   â”‚          â”‚
   â†“          â†“

Success      Error
   â”‚          â”‚
   â†“          â†“

Loaded       Error
  âœ…          âŒ
   â”‚          â”‚
   â†“          â†“

imageUrl: 'https://...'   errorMessage: '...'
isUploading: false        isUploading: false

        â†“

[Usuario puede]
â”œâ”€> Continuar (si 3 imÃ¡genes)
â”œâ”€> Recapturar (presiona botÃ³n de nuevo)
â””â”€> Ver error (si ocurriÃ³ problema)
```

---

## Componentes

### ğŸ“¦ State Management

#### ImageUploadState (Por cada imagen)

```dart
@freezed
abstract class ImageUploadState with _$ImageUploadState {
  const factory ImageUploadState({
    @Default(false) bool isUploading,      // Â¿EstÃ¡ subiendo?
    @Default('') String errorMessage,      // Mensaje de error
    String? imageUrl,                      // URL de la imagen en servidor
    String? localImagePath,                // Path local para preview
  }) = _ImageUploadState;
}
```

**Propiedades:**

-   `isUploading`: `true` mientras se sube, `false` cuando termina
-   `errorMessage`: Texto de error si algo falla
-   `imageUrl`: URL en servidor (si Ã©xito)
-   `localImagePath`: Path local para mostrar preview

#### FirstLoanStepFiveState

Estado general del paso 5 (imÃ¡genes en primer prÃ©stamo):

```dart
@freezed
abstract class FirstLoanStepFiveState with _$FirstLoanStepFiveState {
  const factory FirstLoanStepFiveState({
    @Default(false) bool isLoading,
    @Default('') String errorMessage,
    @Default(ImageUploadState()) ImageUploadState frontIdCard,
    @Default(ImageUploadState()) ImageUploadState backIdCard,
    @Default(ImageUploadState()) ImageUploadState selfie,
    @Default(false) bool isValid,  // Â¿Todas las 3 imÃ¡genes?
  }) = _FirstLoanStepFiveState;
}
```

**Propiedades:**

-   `frontIdCard`: Estado de frente del DUI
-   `backIdCard`: Estado de revÃ©s del DUI
-   `selfie`: Estado de selfie
-   `isValid`: `true` si las 3 estÃ¡n cargadas correctamente

#### FirstLoanStepFiveNotifier

Gestor de estado para carga de imÃ¡genes:

```dart
@Riverpod(keepAlive: true)
class FirstLoanStepFiveNotifier extends _$FirstLoanStepFiveNotifier {
  Future<void> captureAndUploadImage(ImageType imageType) async {
    // 1. Capturar con cÃ¡mara
    // 2. Actualizar estado (uploading)
    // 3. Subir a API
    // 4. Actualizar con URL o error
    // 5. Validar si todas estÃ¡n cargadas
  }

  Map<String, String> getUploadedImageUrls() {
    // Retorna { 'frontIdCard': url, 'backIdCard': url, ... }
  }
}
```

**MÃ©todos principales:**

| MÃ©todo                    | ParÃ¡metro   | DescripciÃ³n              |
| ------------------------- | ----------- | ------------------------ |
| `captureAndUploadImage()` | `ImageType` | Captura y sube imagen    |
| `getUploadedImageUrls()`  | -           | Retorna URLs de imÃ¡genes |
| `clearImageError()`       | `ImageType` | Limpia error de imagen   |

### ğŸ”„ Repository Layer

#### ImageUploadRepository

Encapsula lÃ³gica de carga:

```dart
class ImageUploadRepository {
  final HttpClient _httpClient;

  Future<ImageUploadResponse> uploadImage({
    required String imagePath,
    required ImageType imageType,
  }) async {
    try {
      final file = File(imagePath);
      final fileName = file.path.split('/').last;

      final FormData data = FormData.fromMap({
        'imageType': imageType.apiValue,  // 'frontIdCard', etc
        'imageFile': await MultipartFile.fromFile(
          file.path,
          filename: fileName,
        ),
      });

      final response = await _httpClient.post(
        '/client/upload-images',
        data: data,
      );

      return ImageUploadResponse.fromJson(response.data);
    } on DioException catch (e) {
      // Manejo de errores
    }
  }
}
```

**Responsabilidades:**

-   Crear FormData multipart
-   Enviar peticiÃ³n POST
-   Capturar y transformar errores
-   Retornar URL de imagen

### ğŸ“¦ Models (DTOs)

#### ImageType (Enum)

```dart
enum ImageType {
  frontIdCard,   // Frente del DUI
  backIdCard,    // RevÃ©s del DUI
  selfie;        // Selfie con DUI

  String get apiValue {
    switch (this) {
      case ImageType.frontIdCard:
        return 'frontIdCard';
      case ImageType.backIdCard:
        return 'backIdCard';
      case ImageType.selfie:
        return 'selfie';
    }
  }

  String get displayName {
    switch (this) {
      case ImageType.frontIdCard:
        return 'Frente del DUI';
      case ImageType.backIdCard:
        return 'RevÃ©s del DUI';
      case ImageType.selfie:
        return 'Selfie con DUI';
    }
  }
}
```

#### ImageUploadResponse

```dart
@freezed
abstract class ImageUploadResponse with _$ImageUploadResponse {
  const factory ImageUploadResponse({
    required String imageUrl,  // URL de la imagen en servidor
  }) = _ImageUploadResponse;

  factory ImageUploadResponse.fromJson(Map<String, dynamic> json) =>
      _$ImageUploadResponseFromJson(json);
}
```

### ğŸ¨ UI Components

#### FirstLoanStepFiveScreen / SubsequentLoanStepThreeScreen

Pantalla que muestra los botones para capturar imÃ¡genes:

**Secciones:**

1. TÃ­tulo: "Verifica tu identidad"
2. Instrucciones: "Necesitamos 3 fotos..."
3. BotÃ³n "Capturar frente del DUI"
4. BotÃ³n "Capturar revÃ©s del DUI"
5. BotÃ³n "Capturar selfie con DUI"
6. Indicadores de estado (âœ… o â³ o âŒ)
7. BotÃ³n "Continuar" (habilitado si vÃ¡lido)

#### ImageCaptureWidget

Widget individual para capturar una imagen:

**CaracterÃ­sticas:**

-   Icono del tipo de imagen
-   Nombre descriptivo
-   BotÃ³n para capturar
-   Indicador de estado
-   Mensaje de error si aplica

#### ImagePreviewWidget (Opcional)

Muestra preview de la imagen capturada:

-   Thumbnail de la imagen
-   OpciÃ³n de eliminar/recapturar
-   Muestra URL de servidor

---

## APIs Utilizadas

### Endpoint de Carga

#### `POST /client/upload-images`

**DescripciÃ³n**: Carga una imagen verificada en el servidor.

**Headers Requeridos**:

```
Content-Type: multipart/form-data
Authorization: Bearer <token>
Language: es
```

**Request Body** (FormData):

```
Form Fields:
  - imageType: "frontIdCard" | "backIdCard" | "selfie"
  - imageFile: <archivo binario JPEG/PNG>
```

**ParÃ¡metros:**

-   `imageType`: Tipo de imagen (`frontIdCard`, `backIdCard`, `selfie`)
-   `imageFile`: Archivo de imagen (multipart)

**Validaciones servidor:**

-   Archivo no vacÃ­o
-   Formato vÃ¡lido (JPEG, PNG)
-   TamaÃ±o mÃ¡ximo: 5MB
-   Dimensiones mÃ­nimas: 640x480
-   No es imagen en blanco/corrupta

**Response Exitosa (200 OK)**:

```json
{
    "data": {
        "imageUrl": "https://storage.example.com/images/uuid/frontIdCard.jpg"
    }
}
```

**La URL es permanente y se usa para:**

-   ValidaciÃ³n de identidad
-   Procesamiento de solicitud
-   AuditorÃ­a y cumplimiento

**Respuestas de Error**:

| CÃ³digo | SituaciÃ³n            | Mensaje                       | AcciÃ³n                      |
| ------ | -------------------- | ----------------------------- | --------------------------- |
| 400    | Archivo invÃ¡lido     | "Archivo no vÃ¡lido"           | Recapturar                  |
| 400    | Formato no soportado | "Formato de imagen no vÃ¡lido" | Usar JPEG/PNG               |
| 400    | Imagen corrupta      | "Imagen corrupta o en blanco" | Recapturar                  |
| 401    | No autenticado       | "Usuario no autenticado"      | Redirigir a login           |
| 413    | Archivo muy grande   | "Archivo excede 5MB"          | Usar imagen mÃ¡s pequeÃ±a     |
| 422    | ValidaciÃ³n fallida   | "Imagen no cumple requisitos" | Recapturar con buena luz    |
| 429    | Rate limit           | "Demasiadas peticiones"       | Esperar antes de reintentar |
| 500    | Error servidor       | "Error interno del servidor"  | Reintentar despuÃ©s          |

**Ejemplo error 422:**

```json
{
    "errors": [
        {
            "code": "ValidationError",
            "message": "Imagen debe ser clara y legible"
        }
    ]
}
```

---

## Manejo de Errores

### ğŸš¨ Estrategia de Errores

Errores se capturan en mÃºltiples niveles:

#### 1. Nivel Repository

```dart
class ImageUploadException implements Exception {
  final String message;
  final int? statusCode;
  final ImageUploadExceptionType type;
  final Map<String, dynamic>? data;

  const ImageUploadException({
    required this.message,
    this.statusCode,
    required this.type,
    this.data,
  });
}

enum ImageUploadExceptionType {
  network,      // Errores de red (DioException)
  validation,   // ValidaciÃ³n fallida
  unauthorized, // 401
  unknown,      // Inesperado
}
```

#### 2. Nivel Notifier

```dart
try {
  final response = await _imageUploadRepository.uploadImage(
    imagePath: image.path,
    imageType: imageType,
  );

  // Ã‰xito: actualizar con URL
  _updateImageState(
    imageType,
    isUploading: false,
    imageUrl: response.imageUrl,
  );
} on ImageUploadException catch (e, stackTrace) {
  LoggingService.error(
    'Image upload failed',
    tag: 'IMAGE_UPLOAD',
    error: e,
    data: {
      'image_type': imageType.name,
      'status_code': e.statusCode,
    },
  );

  // Error: mostrar mensaje
  String errorMessage = 'Error al subir imagen';

  if (e.statusCode == 413) {
    errorMessage = 'Archivo demasiado grande';
  } else if (e.statusCode == 422) {
    errorMessage = 'Imagen no cumple requisitos';
  } else if (e.statusCode == 429) {
    errorMessage = 'Intenta mÃ¡s tarde';
  }

  _updateImageState(
    imageType,
    isUploading: false,
    errorMessage: errorMessage,
  );
}
```

#### 3. Nivel UI

```dart
Widget _buildImageStatus(ImageUploadState state, ImageType type) {
  if (state.isUploading) {
    return CircularProgressIndicator(); // â³
  } else if (state.imageUrl != null) {
    return Icon(Icons.check_circle, color: Colors.green); // âœ…
  } else if (state.errorMessage.isNotEmpty) {
    return Column(
      children: [
        Icon(Icons.error, color: Colors.red), // âŒ
        Text(state.errorMessage),
      ],
    );
  }
  return SizedBox.shrink();
}
```

### ğŸ“Š Ãrbol de DecisiÃ³n

```
ImageUploadException
â”‚
â”œâ”€> Tipo: NETWORK
â”‚   â”œâ”€> 400: Archivo/Formato invÃ¡lido
â”‚   â”‚   â””â”€> "Archivo no vÃ¡lido. Intenta de nuevo."
â”‚   â”‚
â”‚   â”œâ”€> 401: No autenticado
â”‚   â”‚   â””â”€> "Tu sesiÃ³n expirÃ³. Inicia sesiÃ³n de nuevo."
â”‚   â”‚   â””â”€> AcciÃ³n: Redirigir a login
â”‚   â”‚
â”‚   â”œâ”€> 408/Timeout
â”‚   â”‚   â””â”€> "Tiempo de conexiÃ³n agotado. Intenta de nuevo."
â”‚   â”‚
â”‚   â”œâ”€> 413: Archivo muy grande
â”‚   â”‚   â””â”€> "La imagen es muy grande (mÃ¡x 5MB)"
â”‚   â”‚
â”‚   â”œâ”€> 422: ValidaciÃ³n fallida
â”‚   â”‚   â”œâ”€> Si imagen en blanco
â”‚   â”‚   â”‚   â””â”€> "Imagen en blanco. AsegÃºrate de iluminaciÃ³n."
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€> Si imagen corrupta
â”‚   â”‚   â”‚   â””â”€> "Imagen corrupta. Recaptura de nuevo."
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€> Otro error validaciÃ³n
â”‚   â”‚       â””â”€> "Imagen no cumple requisitos."
â”‚   â”‚
â”‚   â”œâ”€> 429: Rate limiting
â”‚   â”‚   â””â”€> "Demasiadas peticiones. Espera unos segundos."
â”‚   â”‚
â”‚   â””â”€> 5xx: Error servidor
â”‚       â””â”€> "Error del servidor. Intenta mÃ¡s tarde."
â”‚
â”œâ”€> Tipo: VALIDATION
â”‚   â””â”€> "Datos de validaciÃ³n invÃ¡lidos"
â”‚
â””â”€> Tipo: UNKNOWN
    â””â”€> "Error inesperado: [mensaje]"
```

### ğŸ”„ Manejo de Reintentos

El usuario puede reintentar sin lÃ­mites:

```dart
// Si error, el botÃ³n "Capturar" sigue disponible
// Usuario presiona nuevamente
â†’ captureAndUploadImage() se ejecuta de nuevo

// Cada reintento:
// 1. Limpia errorMessage previo
// 2. Abre cÃ¡mara de nuevo
// 3. Intenta nueva carga
// 4. Actualiza estado con nuevo resultado
```

---

## OptimizaciÃ³n y ValidaciÃ³n

### ğŸ“Š CompresiÃ³n de ImÃ¡genes

```dart
final XFile? image = await _imagePicker.pickImage(
  source: ImageSource.camera,
  imageQuality: 50,  // CompresiÃ³n: 50% de calidad original
);
```

**Beneficios:**

-   Reduce tamaÃ±o: ~5MB â†’ ~1MB
-   Mantiene calidad: Suficiente para OCR
-   Acelera upload: 3-5 segundos vs 10-15 segundos
-   Ahorra datos: Importante en conexiones 3G/4G

### ğŸ“ Validaciones Cliente

Antes de enviar:

```dart
// Validar archivo existe
final file = File(imagePath);
if (!file.existsSync()) {
  throw Exception('Archivo no existe');
}

// Validar tamaÃ±o
final fileSize = file.lengthSync();
if (fileSize > 5 * 1024 * 1024) {  // 5MB
  throw Exception('Archivo muy grande');
}

// Validar extension (opcional)
if (!imagePath.endsWith('.jpg') && !imagePath.endsWith('.png')) {
  throw Exception('Formato no vÃ¡lido');
}
```

### ğŸ–¼ï¸ Preview Local

```dart
// Mostrar preview mientras se carga
if (state.localImagePath != null) {
  return Image.file(
    File(state.localImagePath!),
    fit: BoxFit.cover,
  );
}
```

---

## ğŸ” Seguridad

### Consideraciones Importantes

#### 1. ProtecciÃ³n de ImÃ¡genes

**En trÃ¡nsito:**

-   HTTPS obligatorio (TLS 1.2+)
-   FormData multipart encriptado
-   No se envÃ­a por HTTP

**En servidor:**

-   Almacenamiento en S3/Cloud Storage
-   EncriptaciÃ³n en reposo
-   Acceso mediante URLs firmadas
-   ExpiraciÃ³n de URLs tras procesamiento

**En dispositivo:**

-   Se elimina archivo local despuÃ©s de upload
-   No se guardan en cachÃ© sin permiso
-   Se protegen con permisos del SO

#### 2. ValidaciÃ³n de ImÃ¡genes

**DetecciÃ³n de fraude:**

-   AnÃ¡lisis de metadatos EXIF
-   DetecciÃ³n de ediciÃ³n
-   ValidaciÃ³n de resoluciÃ³n
-   OCR para verificar documento

**LÃ­mites:**

-   MÃ¡ximo 5MB por imagen
-   ResoluciÃ³n mÃ­nima: 640x480
-   MÃ­nimo brillo/contraste

#### 3. AutenticaciÃ³n

-   Token Bearer requerido en headers
-   Validado en cada peticiÃ³n
-   Vinculado a usuario especÃ­fico
-   URL de imagen tied a usuario

#### 4. Permisos del Dispositivo

El app requiere:

-   `CAMERA`: Para capturar fotos
-   `WRITE_EXTERNAL_STORAGE`: Para guardar temporalmente
-   `READ_EXTERNAL_STORAGE`: Para acceder a galerÃ­a

Se solicitan con:

-   `permission_handler` package
-   Permisos runtime en Android 6+

#### 5. Cumplimiento Normativo

-   GDPR: Derecho al olvido (datos se eliminan tras procesamiento)
-   CCPA: Privacidad de datos
-   Regulaciones de prÃ©stamos: VerificaciÃ³n KYC
-   AuditorÃ­a: Logs de quiÃ©n accediÃ³ a imÃ¡genes

---

## ğŸ“ Resumen de Capas

| Capa           | Componente                | Responsabilidad            |
| -------------- | ------------------------- | -------------------------- |
| **UI**         | FirstLoanStepFiveScreen   | Mostrar botones, estados   |
| **UI**         | ImageCaptureWidget        | Widget individual captura  |
| **State**      | FirstLoanStepFiveNotifier | Orquestar carga            |
| **State**      | ImageUploadState          | Mantener estado por imagen |
| **Repository** | ImageUploadRepository     | Carga a API                |
| **Local**      | ImagePicker               | Acceso a cÃ¡mara            |
| **Data**       | HttpClient                | HTTP multipart             |
| **Domain**     | ImageType                 | Tipos de imagen            |

---

## ğŸš€ PrÃ³ximos Pasos

1. **ValidaciÃ³n con AI**: Detectar documentos falsos o editados
2. **Selfie matching**: Comparar cara en selfie con DUI
3. **ComprensiÃ³n OCR**: Extraer datos de documento automÃ¡ticamente
4. **MÃºltiples idiomas**: Soportar otros documentos (pasaporte, etc.)
5. **Descarga de histÃ³rico**: Permitir al usuario descargar sus imÃ¡genes
6. **EdiciÃ³n local**: Permitir recortar/rotar antes de subir
7. **Modo offline**: Cachear y subir cuando haya conexiÃ³n

---

## ğŸ“š Referencia de Archivos

```
ğŸ“ lib/features/first_loan/
â”œâ”€â”€ ğŸ“„ entities/image_type_enum.dart
â”œâ”€â”€ ğŸ“„ models/image_upload_request.dart
â”œâ”€â”€ ğŸ“„ models/image_upload_response.dart
â”œâ”€â”€ ğŸ“„ providers/first_loan_step_five_provider.dart
â”œâ”€â”€ ğŸ“„ repositories/image_upload_repository.dart
â””â”€â”€ ğŸ“„ screens/first_loan_step_five_screen.dart

ğŸ“ lib/features/subsequent_loan/
â”œâ”€â”€ ğŸ“„ entities/image_type_enum.dart
â”œâ”€â”€ ğŸ“„ models/image_upload_response.dart
â”œâ”€â”€ ğŸ“„ repositories/subsequent_image_upload_repository.dart
â””â”€â”€ ğŸ“„ screens/subsequent_loan_step_three_screen.dart
```

---

## ğŸ”— RelaciÃ³n con Otros Features

-   **Primer PrÃ©stamo**: Paso 5 - VerificaciÃ³n de identidad
-   **PrÃ©stamo Posterior**: Paso 3 - VerificaciÃ³n de identidad
-   **Perfil del Cliente**: Recargar imÃ¡genes si son rechazadas
-   **AutenticaciÃ³n**: Requiere token Bearer vÃ¡lido

---

**VersiÃ³n**: 1.0
**Ãšltima actualizaciÃ³n**: Octubre 2024
**Autor**: Equipo de Desarrollo Pisto
**Estado**: ProducciÃ³n âœ…
